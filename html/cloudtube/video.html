<!-- TEMPLATE pre -->
<link rel="stylesheet" type="text/css" href="/cloudtube/youtube.css">
<title></title>
<script src="/cloudtube/cloudtube.js"></script>
<!-- metaOGTags -->
<script type="text/javascript">
    function prettySeconds(seconds) {
        let minutes = Math.floor(seconds / 60);
        seconds = seconds % 60;
        let hours = Math.floor(minutes / 60);
        minutes = minutes % 60;
        let output = [];
        if (hours) {
            output.push(hours);
            output.push(minutes.toString().padStart(2, "0"));
        } else {
            output.push(minutes);
        }
        output.push(seconds.toString().padStart(2, "0"));
        return output.join(":");
    }

    let videoID;
    let formats;
    let allFormats;
    let bestAudioURL;
    let checkingAudioURLs;
    let lastCurrentTime = 0;

    function chooseFormat(index) {
        let format = formats[index];
        let video = q("video");
        video.preload = "auto";
        let qs = q("#qualitySelect");
       // console.log("saving last time: "+video.currentTime);
        lastCurrentTime = video.currentTime;
        if (format.index) {
            if (bestAudioURL) {
                q("audio").src = bestAudioURL;
            } else if (!checkingAudioURLs) { // So apprently sometimes Vivaldi on Linux doesn't load the audio length properly so I pick one that works
                checkingAudioURLs = true;
                Promise.all(allFormats.filter(f => f.type.includes("audio")).map(f => {
                    return new Promise(resolve => {
                        let audio = document.createElement("audio");
                        audio.src = f.url;
                        audio.addEventListener("loadeddata", () => {
                            console.log(f.bitrate, f.type, audio.duration);
                            resolve({f, audio});
                        });
                    });
                })).then(results => {
                    let lengths = [];
                    for (let r of results) {
                        if (!lengths.find(l => Math.abs(l-r.audio.duration) < 1)) lengths.push(r.audio.duration);
                    }
                    let bestLength = lengths.sort((a, b) => (b - a))[0];
                    let best = results
                        .filter(r => Math.abs(bestLength-r.audio.duration) < 1)
                        .sort((a, b) => (b.f.bitrate - a.f.bitrate))[0];
                    bestAudioURL = best.f.url;
                    checkingAudioURLs = false;
                    q("audio").src = bestAudioURL;
                });
            }
        } else {
            q("audio").removeAttribute("src");
            q("audio").pause();
        }
        video.src = format.url;
        for (let option of qs.children) {
            option.removeAttribute("selected");
        }
        qs.children[index].setAttribute("selected", "");
    }

    function loadLastTime() {
        //console.log("loading last time: "+lastCurrentTime);
        q("video").currentTime = lastCurrentTime;
    }

    class BetterTimeout {
        constructor(callback, delay) {
            this.callback = callback;
            this.delay = delay;
            if (this.callback) {
                this.isActive = true;
                this.timeout = setTimeout(this.callback, this.delay);
            } else {
                this.isActive = false;
                this.timeout = null;
            }
        }
        triggerNow() {
            this.clear();
            this.callback();
        }
        clear() {
            this.isActive = false;
            clearTimeout(this.timeout);
        }
    }

    function playbackIntervention(event) {
        console.log(event.target.tagName.toLowerCase(), event.type);
        let video = q("video");
        let audio = q("audio");
        if (audio.src) {
            let target = event.target;
            let other = (event.target.tagName == "VIDEO" ? audio : video);
            switch (event.type) {
            case "canplaythrough":
                target.waitingTimeout.clear();
                if (video.ready && audio.ready) return; // console.log("ignoring canplaythrough; already ready");
                target.ready = true;
                if (video.ready && audio.ready) {
                    if (!video.manualPaused) video.play();
                    console.log("both ready");
                }
                break;
            case "durationchange":
                target.ready = false;
                break;
            case "seeked":
                target.ready = false;
                target.pause();
                other.currentTime = target.currentTime;
                break;
            case "pause":
            case "playing":
            case "play":
                inProgress = true;
                other.currentTime = target.currentTime;
                if (event.type.startsWith("play")) {
                    target.manualPaused = false;
                    other.play();
                } else {
                    target.manualPaused = true;
                    other.pause();
                }
                break;
            case "ratechange":
                other.rate = target.rate;
                break;
            case "stalled":
            case "waiting":
                if (target.waitingTimeout.isActive) {
                    target.waitingTimeout.triggerNow();
                } else if (other.waitingTimeout.isActive) {
                    other.waitingTimeout.triggerNow();
                } else {
                    target.waitingTimeout.clear();
                    target.waitingTimeout = new BetterTimeout(() => {
                        target.ready = false;
                        target.pause();
                    }, 1000);
                }
                break;
            }
        } else {
            if (event.type == "canplaythrough" && !video.manualPaused) video.play();
        }
    }

    function adjustSpeedSlider() {
        let speedSlider = q("#speedSlider");
        q("video").playbackRate = speedSlider.value/1000;
        q("audio").playbackRate = speedSlider.value/1000;
        q("#speedLabel").innerText = Math.floor(speedSlider.value/10)+"%";
    }

    function resetSpeed() {
        let speedSlider = q("#speedSlider");
        speedSlider.value = 1000;
        adjustSpeedSlider();
    }

    function seekTo(seconds) {
        q("video").currentTime = seconds;
    }

    function checkSubscribedStatus() {
        return lsm.array("subscriptions").array.includes(q("#videoAuthor").getAttribute("data-channelid"));
    }

    function updateSubscribeButton() {
        q("#subscribe").innerText = checkSubscribedStatus() ? "Unsubscribe" : "Subscribe";
    }

    function toggleSubscription() {
        let channelID = q("#videoAuthor").getAttribute("data-channelid");
        let token = lsm.get("token");
        if (token) {
            let s = q("#subscribe");
            s.style.width = s.offsetWidth;
            s.innerText = "...";
            s.disabled = true;
            request(`/api/youtube/subscribe`, result => {
                if (result.status == 200) {
                    let data = JSON.parse(result.responseText);
                    if (checkSubscribedStatus() != data.nowSubscribed) {
                        updateLocalStorage();
                    }
                    s.style.width = "";
                    updateSubscribeButton();
                } else {
                    console.log(result);
                    s.innerText = "error.";
                }
                s.disabled = false;
            }, {token, channelID});
        } else {
            updateLocalStorage();
            updateSubscribeButton();
        }
    }
    function updateLocalStorage() {
        let channelID = q("#videoAuthor").getAttribute("data-channelid");
        if (checkSubscribedStatus()) {
            lsm.array("subscriptions").remove(channelID);
        } else {
            lsm.array("subscriptions").add(channelID);
        }
    }

    function switchServers(remember) {
        if (remember) lsm.set("automaticSourceSwitch", "1");
        q("#playbackErrorContainer").innerText = "Please wait, requesting new sources...";
        request("/api/youtube/alternate/"+videoID, body => {
            let data = JSON.parse(body.responseText);
            if (data.error == "No servers available for your country") {
                q("#playbackErrorContainer").innerHTML =
                "There are no Invidious servers in your country."+
                "<a href='/about/contact' target='_blank'>Please contact me with your country and I'll try to set up a server.</a><br>"+
                "For now, you should just watch the video on regular YouTube.";
            } else if (data.error) {
                q("#playbackErrorContainer").innerHTML = "An error occurred. Try reloading the page. If you still see this error, <a href='/about/contact' target='_blank'>please report it.</a><br><br><code>"+body.responseText+"</code>";
                q("#playbackErrorContainer").style["word-break"] = "break-all";
            } else {
                let qualitySelect = q("#qualitySelect");
                let child;
                while (child = qualitySelect.children[0]) {
                    child.parentElement.removeChild(child);
                }
                allFormats = data.formatStreams.concat(data.adaptiveFormats);
                formats = allFormats.filter(f => f.type.includes("video") && f.qualityLabel);
                for (let i = 0; i < formats.length; i++) {
                    let f = formats[i];
                    f.label = (f.qualityLabel || f.resolution) + " " + f.container + (f.index ? " ꜝ" : "") ;
                    let option = document.createElement("option");
                    option.setAttribute("value", i);
                    option.innerText = f.label;
                    qualitySelect.appendChild(option);
                }
                chooseFormat(formats.findIndex(f => f.container == "mp4") || 0);
                q("#playbackErrorContainer").style.display = "none";
            }
        });
    }

    function bodyLoad() {
        let video = q("video");
        let audio = q("audio");
        for (let eventName of ["pause", "play", "seeked"]) {
            video.addEventListener(eventName, playbackIntervention);
        }
        for (let eventName of ["canplaythrough", "waiting", "stalled"]) {
            video.addEventListener(eventName, playbackIntervention);
            audio.addEventListener(eventName, playbackIntervention);
        }
        video.manualPaused = true;
        let ignorePlaybackError = false;
        video.addEventListener("error", event => {
            if (ignorePlaybackError) return;
            console.log(event, video);
            if (lsm.get("automaticSourceSwitch") == "1") {
                switchServers();
            }
            q("#playbackErrorContainer").style.display = "";
        });
        window.addEventListener("beforeunload", () => ignorePlaybackError = true);
        q("#speedSliderContainer").children[0].addEventListener("mousewheel", event => {
            let offset = 50 * Math.sign(event.deltaY) * Math.sign(-event.shiftKey + 0.5);
            q("#speedSlider").value = q("#speedSlider").value - offset;
            adjustSpeedSlider();
            event.preventDefault();
        });
        video.waitingTimeout = new BetterTimeout();
        audio.waitingTimeout = new BetterTimeout();
        let data = "<!-- videoInfo -->";
        videoID = data.videoId;
        // Set buttons below video
        getLoginDetails(details => {
            if (details && details.subscriptions) {
                updateLocalStorage();
                let subscriptionsString = "";
                for (let s of details.subscriptions) subscriptionsString += s+",";
                lsm.array("subscriptions").read(subscriptionsString);
                updateSubscribeButton();
            } else {
                updateSubscribeButton();
            }
        });
        q("#youtubeLink").setAttribute("href", `https://youtube.com/watch?v=${videoID}&feature=cloudtube`);
        q("#invidiousLink").setAttribute("href", `https://invidio.us/watch?v=${videoID}&feature=cloudtube`);
        q("#hooktubeLink").setAttribute("href", `https://hooktube.com/watch?v=${videoID}&feature=cloudtube`);
        q("#legacyLink").setAttribute("href", `/legacy/${videoID}`);
        // Load video
        //formats = allFormats.filter(f => usefulFormats.includes(f.itag)/* && f.audioEncoding*/);
        allFormats = data.formatStreams.concat(data.adaptiveFormats);
        formats = allFormats.filter(f => f.type.includes("video") && f.qualityLabel);
        for (let i = 0; i < formats.length; i++) {
            let f = formats[i];
            f.label = (f.qualityLabel || f.resolution) + " " + f.container + (f.index ? " ꜝ" : "") ;
            let option = document.createElement("option");
            option.setAttribute("value", i);
            option.innerText = f.label;
            q("#qualitySelect").appendChild(option);
        }
        chooseFormat(formats.findIndex(f => f.container == "mp4") || 0);
        // Set video elements
        q("#videoTitle").innerText = data.title;
        q("#videoAuthor").innerText = "Uploaded by "+data.author;
        q("#videoAuthor").href = "/cloudtube/channel/"+data.authorId;
        q("#videoAuthor").setAttribute("data-channelid", data.authorId);
        q(".videoDescription").innerHTML = data.descriptionHtml;
        data.viewCount = data.viewCount.toString();
        let commaViewCount = data.viewCount;
        for (let i = 1; i < data.viewCount.length/3; i++) {
            let invi = commaViewCount.length - i*3 - i + 1;
            commaViewCount = commaViewCount.slice(0, invi) + "," + commaViewCount.slice(invi);
        }
        q("#videoViews").innerText = commaViewCount+" views";
        q("#videoUploaded").innerText = "Uploaded "+humaniseDate(data.published*1000);
        let percentRating = data.rating/5*100;
        q("#videoRatingBar").style.background = `linear-gradient(to right, #208819 ${percentRating}%, #ccc ${percentRating}%)`;
        // Set related videos
        let relatedVideos = data.recommendedVideos.filter(rv => rv.title && rv.author && rv.videoId && rv.lengthSeconds);
        let filterReturn = filterVideos(relatedVideos, "related");
        relatedVideos = filterReturn[0];
        for (let i = 0; i < relatedVideos.length; i++) {
            let rv = relatedVideos[i];
            let ne = q("#relatedVideosStorage").children[0].cloneNode(true);
            ne.children[1].children[0].innerText = rv.title;
            ne.children[1].children[1].innerText = rv.author+" • "+rv.viewCountText;
            ne.children[0].children[0].src = `https://invidio.us/vi/${rv.videoId}/mqdefault.jpg`;
            document.styleSheets[1].insertRule(`.relatedVideo:nth-child(${i+2}) > div:first-child::before { content: "${prettySeconds(rv.lengthSeconds)}"; }`);
            ne.href = rv.videoId;
            q("#relatedVideosContainer").appendChild(ne);
        }
        if (filterReturn[1]) {
            q("#blockedWarning").parentElement.appendChild(q("#blockedWarning"));
            q("#blockedWarning").style.display = "";
            q("#blockedWarning span").innerText = filterReturn[1];
        }
        // Fix description
        [...q("#eow-description").children].filter(c => c.tagName == "A").forEach(c => {
            if (c.innerText.startsWith("#")) {
                c.removeAttribute("href");
            } else {
                let href = c.getAttribute("href");
                if (href.startsWith("/redirect")) {
                    href = href.replace(/^.*\?/, "");
                    c.setAttribute("href", new URLSearchParams(href).get("q"));
                } else if (href.match(/^https?:\/\/(www\.)?youtube\.com\/channel\/([^\/]{12,})/)) {
                    c.setAttribute("href", href.replace(/.*channel/, "/cloudtube/channel"));
                } else {
                    c.setAttribute("href", href.replace(/^.*=/, ""));
                }
            }
        });
        // Record video as watched in localStorage
        if (lsm.get("trackWatchedVideos")) {
            let videoID = window.location.href.match("/video/([\\w-]+)")[1];
            lsm.array("watchedVideos").add(videoID);
        }
    }

    document.addEventListener("keydown", event => {
        if (event.repeat) return;
        let video = q("video");
        let audio = q("audio");
        let audioSource = audio.src ? audio : video;
        let speedSlider = q("#speedSlider");
        let caught = true;
        if (event.key == " " || event.key == "p" || event.key == "k") {
            if (video.paused) video.play();
            else video.pause();
        } else if (event.key == "ArrowLeft") {
            video.currentTime -= 5;
        } else if (event.key == "ArrowRight") {
            video.currentTime += 5;
        } else if (event.key == "ArrowUp") {
            audioSource.volume += 0.1;
        } else if (event.key == "ArrowDown") {
            audioSource.volume -= 0.1;
        } else if (event.key == "j") {
            video.currentTime -= 10;
        } else if (event.key == "l") {
            video.currentTime += 10;
        } else if (event.key == "\\") {
            resetSpeed();
        } else if (event.key == "[") {
            speedSlider.value -= 100;
            adjustSpeedSlider();
        } else if (event.key == "]") {
            speedSlider.value -= -100;
            adjustSpeedSlider();
        } else if (!isNaN(+event.key)) {
            video.currentTime = (+event.key)/10*video.duration;
        } else if (event.key == "f") {
            let browserMap;
            if (document.webkitFullscreenElement !== undefined) {
                methodMap = {
                    element: () => document.webkitFullscreenElement,
                    enter: () => video.webkitRequestFullScreen(),
                    exit: () => document.webkitCancelFullScreen()
                }
            } else if (document.mozFullScreenElement !== undefined) {
                methodMap = {
                    element: () => document.mozFullScreenElement,
                    enter: () => video.mozRequestFullScreen(),
                    exit: () => document.mozCancelFullScreen()
                }
            }
            if (methodMap.element()) {
                methodMap.exit();
            } else {
                methodMap.enter();
            }
        } else {
            caught = false;
        }
        if (caught) event.preventDefault();
    });
</script>
<!-- TEMPLATE header -->
<div id="mainContainer">
    <div style="flex: 1;">
        <div class="videoContainer">
            <video controls preload="auto" ondurationchange="loadLastTime()"></video>
        </div>
        <div class="videoInfoBox">
            <div>
                <span id="videoTitle">Placeholder title</span>
                <a id="videoAuthor">Placeholder author</a>
            </div>
            <div id="videoRightContainer">
                <div id="videoUploaded">Placeholder upload date</div>
                <div id="videoViews">Placeholder views</div>
                <span id="videoRatingBar"></span>
            </div>
        </div>
        <audio preload="auto"></audio>
        <div class="belowButtonContainer infoBox" id="playbackErrorContainer" style="display: none;">
            <div>
                <span>
                    <div>
                        Looks like the video stream can't be played.<br>
                        This issue can probably be fixed by rerouting you to a different Invidious server,
                        but this involves sending your IP address to an external API.
                    </div>
                    <div>
                        <button onclick="switchServers(false)">Use another server</button><button onclick="switchServers(true)">Do this automatically from now on</button>
                    </div>
                </span>
            </div>
        </div>
        <div class="belowButtonContainer">
            <button id="subscribe" onclick="toggleSubscription()">Subscribe</button>
            <select id="qualitySelect" oninput="chooseFormat(event.target.selectedIndex)"></select>
            <span id="speedSliderContainer"><span><span class="speedText">Speed:</span><span id="speedLabel" onclick='resetSpeed()' title="Click to reset">100%</span><input type="range" list="speeds" id="speedSlider" min="100" max="5000" value="1000" step="1" oninput="adjustSpeedSlider()"></span></span>
        </div>
        <div class="belowButtonContainer">
            <a class="linkbutton" href="/cloudtube/subscriptions"><img src="/fonts/search.svg" style="position: relative; top: 2px; margin: 0px 8px 0px 4px;">Search</a>
            <a class="linkbutton" id="youtubeLink">Watch on YouTube</a>
            <a class="linkbutton" id="invidiousLink">Watch on Invidious</a>
            <a class="linkbutton" id="hooktubeLink">Watch on HookTube</a>
            <a class="linkbutton" id="legacyLink">Watch on legacy</a>
        </div>
        <div class="videoDescription">
            Placeholder description
        </div>
    </div>
    <div id="relatedVideosContainer">
        <div>Related videos</div>
        <div id="blockedWarning" style="display: none;"><span></span> videos blocked. <a href="/cloudtube/settings">Edit preferences</a></div>
    </div>
</div>
<div id="relatedVideosStorage" style="display:none;">
    <a href="#" class="relatedVideo">
        <div>
            <img>
        </div>
        <div>
            <span>Placeholder name</span>
            <span>Placeholder author</span>
        </div>
    </a>
</div>
<!-- TEMPLATE end -->